
# 笔记_回溯算法
原文链接：

[从全排列问题开始理解「回溯」算法（深度优先遍历 + 状态重置 + 剪枝）](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

[扒一扒回溯算法的裤子](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/)

1. 简介

回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现当前选择并不优或达不到目标，就退回上一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

“回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，是为了节约空间而使用的一种技巧。

回溯的思想是把问题的解空间转化成图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。可以发现回溯其实是“深度优先遍历”特有的一种现象。之所以是“深度优先遍历”，是因为我们要解决的问题通常是在一棵树上完成的，在这棵树上搜索需要的答案，一般使用深度优先遍历。下图是一个二叉树（这里只是用二叉树举例，回溯的问题解树结构一般是多叉树）的深度优先遍历过程，也可以说是回溯法的过程，以供参考
![回溯过程](https://github.com/lzk1012/algorithm009-class01/blob/master/Week_03/backTracking.png)

2. 回溯算法详细规则

回溯算法首先将问题的解空间转化成树的结构，然后进行深度优先遍历，以穷举所有可能性。当算法搜索至解空间树的某一节点时，先利用剪枝函数判断该节点是否可行（即排除某些得不到问题解的情况）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。

回溯法的基本行为是搜索，搜索过程使用剪枝函数来为了避免无效的搜索。剪枝函数包括两类：1. 使用约束函数，剪去不满足约束条件的路径；2.使用限界函数，剪去不能得到最优解的路径。

回溯算法的主要问题关键在于如何定义问题的解空间，转化成树（即解空间树）。解空间树分为两种：子集树和排列树。两种在算法结构和思路上大体相同。

3. 算法模板

先定义三个术语：
- 路径：也就是已经做出的选择。这个也就是需要回溯的。
- 选择列表：也就是你当前可以做的选择。
- 结束条件：也就是到达树底层，无法再做选择的条件。
```
result = []
function backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```
其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」

4. 举例-全排列

“全排列”就是一个非常经典的“回溯”算法的应用。N个数字的全排列一共有 N! 这么多个。以数组 [1, 2, 3] 的全排列为例。
- 先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]；
- 再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]；
- 最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]。
那么将这个解空间转换成树状结构，即为下图
![全排列回溯算法](https://github.com/lzk1012/algorithm009-class01/blob/master/Week_03/permutations.png)

那么，套用之前的模板：
- 路径：已选择的数字。比如搜索走到上图第三层第一个节点时，路径为[1,2]
- 选择列表：数组[1,2,3]。只是这里面的数据，已经选择过的不能再选，这方面涉及到剪枝
- 结束条件：路径中元素个数为3。

附上一段代码实现：

```
public class _46_Permutations {
    // 使用一个动态数组保存所有可能的全排列
    List<List<Integer>> result = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        // 首先是特判
        if(len < 1){
            return result;
        }
        Deque<Integer> stack = new ArrayDeque<>();
        // 使用一个数组表示元素是否使用过，在剪枝的时候使用
        int[] used = new int[len];
        doPermute(nums,used,stack);
        return result;
    }

    private void doPermute(int[] nums,int[] used,Deque<Integer> stack) {
        int len = nums.length;
        if(stack.size() == len){
            // 变量stack引用传递
            result.add(new ArrayList<>(stack));
            return;
        }
        for(int i = 0;i<len;i++){
            // 剪枝处理：此元素若已经使用过，跳过
            if(used[i] == 0){
                stack.addLast(nums[i]);
                used[i] = 1;
                doPermute(nums,used,stack);
                // 回溯。代码在形式上和递归之前是对称的
                used[i] = 0;
                stack.removeLast();
            }
        }
    }
}
```

5. 复杂度分析

这部分设计到大串数学公式，没有看，具体在原文链接中。
总之，回溯算法的时间复杂度一般都比较高，基本不可能低于O(N!)。因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。

6. 不回溯可以么

可以。不过搜索问题的状态空间一般很大，如果每一个状态都去创建新的变量，时间复杂度是 O(N)。在候选数比较多的时候，在非叶子结点上创建新的状态变量的性能消耗就很严重。

比如前文中的代码实现，完全可以在递归调用之前，把要传入的参数复制一份出来
7. 总结

回溯法将一个问题的解题空间转换成一个N叉树，然后进行深度优先遍历，直至叶子节点，若此时满足条件，则输出。遍历中如果当前步骤不满足条件或者得不到问题解，则回溯至上一步骤，并在上一步骤中选择其他可能性，直至穷举完所有可能或者得到问题解。

此类回溯算法解题前，最好是先画图，转换成树形图之后，才更容易想清楚递归结构，想清楚如何剪枝
